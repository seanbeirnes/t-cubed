// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: move_event.sql

package repository

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createMoveEvent = `-- name: CreateMoveEvent :one
INSERT INTO move_event (uuid, game_uuid, trace_uuid, move_sequence, player_id, post_move_state)
VALUES (uuid_generate_v4(), $1, $2, $3, $4, $5)
RETURNING uuid, game_uuid, trace_uuid, move_sequence, player_id, post_move_state, created_at, updated_at
`

type CreateMoveEventParams struct {
	GameUuid      uuid.UUID
	TraceUuid     *uuid.UUID
	MoveSequence  int16
	PlayerID      int16
	PostMoveState []byte
}

func (q *Queries) CreateMoveEvent(ctx context.Context, arg CreateMoveEventParams) (MoveEvent, error) {
	row := q.db.QueryRow(ctx, createMoveEvent,
		arg.GameUuid,
		arg.TraceUuid,
		arg.MoveSequence,
		arg.PlayerID,
		arg.PostMoveState,
	)
	var i MoveEvent
	err := row.Scan(
		&i.Uuid,
		&i.GameUuid,
		&i.TraceUuid,
		&i.MoveSequence,
		&i.PlayerID,
		&i.PostMoveState,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listGameMoveEvents = `-- name: ListGameMoveEvents :many
SELECT uuid, game_uuid, trace_uuid, move_sequence, player_id, post_move_state, created_at, updated_at FROM move_event
WHERE game_uuid = $1
`

func (q *Queries) ListGameMoveEvents(ctx context.Context, gameUuid uuid.UUID) ([]MoveEvent, error) {
	rows, err := q.db.Query(ctx, listGameMoveEvents, gameUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MoveEvent
	for rows.Next() {
		var i MoveEvent
		if err := rows.Scan(
			&i.Uuid,
			&i.GameUuid,
			&i.TraceUuid,
			&i.MoveSequence,
			&i.PlayerID,
			&i.PostMoveState,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGameMoveEventsWithTrace = `-- name: ListGameMoveEventsWithTrace :many
SELECT move_event.uuid, game_uuid, trace_uuid, move_sequence, player_id, post_move_state, move_event.created_at, move_event.updated_at, trace_cache.uuid, pre_post_move_state_hash, trace, trace_cache.created_at, trace_cache.updated_at FROM move_event
LEFT JOIN trace_cache ON trace_cache.uuid = move_event.trace_uuid
WHERE move_event.game_uuid = $1
ORDER BY move_event.move_sequence
`

type ListGameMoveEventsWithTraceRow struct {
	Uuid                 uuid.UUID
	GameUuid             uuid.UUID
	TraceUuid            *uuid.UUID
	MoveSequence         int16
	PlayerID             int16
	PostMoveState        []byte
	CreatedAt            time.Time
	UpdatedAt            time.Time
	Uuid_2               *uuid.UUID
	PrePostMoveStateHash []byte
	Trace                []byte
	CreatedAt_2          *time.Time
	UpdatedAt_2          *time.Time
}

func (q *Queries) ListGameMoveEventsWithTrace(ctx context.Context, gameUuid uuid.UUID) ([]ListGameMoveEventsWithTraceRow, error) {
	rows, err := q.db.Query(ctx, listGameMoveEventsWithTrace, gameUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGameMoveEventsWithTraceRow
	for rows.Next() {
		var i ListGameMoveEventsWithTraceRow
		if err := rows.Scan(
			&i.Uuid,
			&i.GameUuid,
			&i.TraceUuid,
			&i.MoveSequence,
			&i.PlayerID,
			&i.PostMoveState,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Uuid_2,
			&i.PrePostMoveStateHash,
			&i.Trace,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
